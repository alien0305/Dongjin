<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h2>JavaScript Closures</h2>

    <p>Counting with a local variable.</p>
    
    <button type="button" onclick="myFunction()">Count!</button>
    
    <p id="demo">0</p>
    
    <script>
    // 1. add function : function을 return
    // higer order function : function에 parameter로 function을 대입하거나 function을 return하는 function
    // 2. IIFE(immediately invoked function expression) : function을 선언함과 동시에 즉시 실행 : (function(){})()
    // 3. add = function () {counter += 1; return counter;};
    //   - add 의 부모 function 에서 선언된 메모리에 존재하는 counter 변수에 대하여
    //     연결고리를 javascript engine이 알아서 만들어 줌
    //   - add() 함수를 실행할 때 마다, 연결고리를 가진 부모 function 에서 선언된 counter 변수의 값을 계속 변경 가능하게 만듬
    //   - 마치 java의 private 으로 선언 된 변수를 관리하는 효과를 가짐 (counter 값은 오직 add() 함수를 실행할 때만 변경 가능)
    //     .counter 값은 오직 add() 함수를 실행할 때만 변경 가능 (기타 다른 방법으로 counter 변수값을 직접 수정 불가)  
    //     => 부모 function에서 선언된 변수를 자식 함수에서 사용함으로서 자식 함수에서만 부모의 변수를 사용하는 것을 closure(폐쇄, 포함)라고 함
    //       . 수학에서의 close와 같은 개념 (집합 A에서 원소 a1이 A에 포함되어 있다면 이 것을 close 되어 있다고 함)
    // 4. closure 성립조건
    //   1) 부모 function 에서 자식 function을 return 해야함 (high order function)
    //   2) 부모 function 에서 선언된 변수를 자식 function에서 사용
    // 5. closure 효과 : 부모 function 에서 선언된 변수들을 private scope 으로 사용 가능
    const add = (function () {
      let counter = 0;
      return function () {counter += 1; return counter;}
    })();
    
    function myFunction(){
      document.getElementById("demo").innerHTML = add();
    }
    </script>
</body>
</html>